?dnorm
?dunif
# Import libraries
package.list <- c(
'nimble',
'coda',
'lme4',
'lmerTest',
'lsmeans',
'ggplot2',
'dplyr',
'tidyr'
)
packageLoad <- function(packages){
for (i in packages) {
if (!require(i, character.only = TRUE)) {
install.packages(i)
library(i, character.only = TRUE)
}
}
}
packageLoad(package.list)
# Import data
tss_df <- read.csv("./Example Data/tss.csv", header = TRUE)
getwd()
# Set working directory to runoff-mcmc folder
setwd(dirname(getwd()))
# Import data
tss_df <- read.csv("./Example Data/tss.csv", header = TRUE)
# View the first few rows of the data to ensure proper import
head(tss_df)
# Convert columns to their respective data types
tss_df$date <- as.Date(tss_df$date, format="%m/%d/%Y")
tss_df$year <- as.factor(tss_df$year)
tss_df$yi <- as.factor(tss_df$yi)
tss_df$id <- as.factor(tss_df$id)
tss_df$block <- as.factor(tss_df$block)
tss_df$trt <- as.factor(tss_df$trt)
tss_df$irr <- as.factor(tss_df$irr)
tss_df$tss <- as.numeric(tss_df$tss)
tss_df$out <- as.numeric(tss_df$out)
tss_df$tssl <- as.numeric(tss_df$tssl)
# Print the structure of the dataframe to confirm data types
str(tss_df)
# Get a summary of the data
summary(tss_df)
# Creating prior std. dev.'s for MCMC (see README.md notes on this)
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
# Let user know what column they have selected
cat(paste0("Recommended priors based on column: '", column_name, "'\n\n"))
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
trt = max(tapply(.data[[column_name]], trt, sd)),
block = max(tapply(.data[[column_name]], block, sd)),
year = max(tapply(.data[[column_name]], year, sd)),
yi = max(tapply(.data[[column_name]], yi, sd)),
id = max(tapply(.data[[column_name]], id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
# Test the function
priors_tss <- recommend_priors(tss_df, 'tss')
priors_tss
# Step 1: Build the model
code <- nimbleCode({
# Fixed effects
beta0 ~ dnorm(0, sd = 0.8)
# Looping over the elements of betaTrt and betaYear
for(k in 1:3) {
betaTrt[k] ~ dnorm(1, sd = 0.8)
}
for(k in 1:maxYear) {
betaYear[k] ~ dnorm(0, sd = 1.2)
}
# Random effects
# Gelman (2006) recommends the uniform prior on the sd scale not the precision scale for random effects:
# E.g., u_yi[j] ~ dnorm(0, sd = tau_yi) NOT u_yi[j] ~ dnorm(0, tau_yi)
# yi
for(j in 1:nyi) {
u_yi[j] ~ dnorm(0, sd = tau_yi)
}
# block
for(j in 1:nblock) {
u_block[j] ~ dnorm(0, sd = tau_block)
}
# id
for(j in 1:nid) {
u_id[j] ~ dnorm(0, sd = tau_id)
}
tau_yi ~ dunif(0, 2)
tau_block ~ dunif(0, 0.8)
tau_id ~ dunif(0, 1)
sigma ~ dunif(0, 2) # prior for variance components based on Gelman (2006);
for(i in 1:n) {
tss[i] ~ dnorm(beta0 + betaTrt[trt[i]] + betaYear[year[i]] +
u_yi[yi[i]] + u_block[block[i]] + u_id[id[i]], sd = sigma)
}
})
constants <- list(
n = nrow(tss_df),
nyi = length(unique(tss_df$yi)),
nblock = length(unique(tss_df$block)),
nid = length(unique(tss_df$id)),
maxYear = length(unique(tss_df$year)),
# Converting factors to numeric below for MCMC
trt = as.numeric(tss_df$trt),
yi = as.numeric(tss_df$yi),
id = as.numeric(tss_df$id),
year = as.numeric(tss_df$year),
block = as.numeric(tss_df$block)
)
data <- list(
tss = tss_df$tss
)
inits <- list(
beta0 = mean(tss_df$tss),
betaTrt = rep(0, 3), # Initial values for three levels of 'trt'
betaYear = rep(0, constants$maxYear),
sigma = 1,
tau_yi = 1,
tau_block = 1,
tau_id = 1,
u_yi = rep(0, constants$nyi),
u_block = rep(0, constants$nblock),
u_id = rep(0, constants$nid)
)
TSSmodel <- nimbleModel(
code,
constants = constants,
data = data,
inits = inits
)
?nimbleMCMC
?numbleModel
?nimbleModel
# Step 2: Build the MCMC
TSSmcmc <- buildMCMC(TSSmodel, enableWAIC = TRUE)
?buildMCMC
# Step 3: Compile the model and MCMC
cTSSmodel <- compileNimble(TSSmodel)
cTSSmcmc <- compileNimble(TSSmcmc, project = TSSmodel)
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=0, #1000
WAIC=TRUE)
)
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
samples
# Watanabe-Akaike Information Criterion (WAIC): captures model fit
# Log Pointwise Predictive Density (LPPD): captures model complexity
# effective number of parameters in the model (pWAIC): balances previous two
# The relationship: WAIC=−2×lppd+2×pWAIC
WAIC <- TSSresults$WAIC
WAIC
plot(as.mcmc(samples))
plot(as.mcmc(samples))
plot(as.mcmc(samples))
plot(as.mcmc(samples))
dev.off()
plot(as.mcmc(samples))
# Step 6: Inspect Results
pdf('./Output/mcmcOutput1.pdf')
plot(as.mcmc(samples))
dev.off()
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000, #1000
WAIC=TRUE)
)
?runMCMC
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000, #1000
WAIC=TRUE,
nchains=2)
)
cat("Sampling time: ", time_baseline[3], "seconds.\n")
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
samples
# Watanabe-Akaike Information Criterion (WAIC): captures model fit
# Log Pointwise Predictive Density (LPPD): captures model complexity
# effective number of parameters in the model (pWAIC): balances previous two
# The relationship: WAIC=−2×lppd+2×pWAIC
WAIC <- TSSresults$WAIC
WAIC
?waic
WAIC
# Step 6: Inspect Results
pdf('./Output/mcmcOutput1.pdf')
plot(as.mcmc(samples))
# Step 6: Inspect Results
pdf('./Output/mcmcOutput1.pdf')
plot(as.mcmc(samples))
dev.off()
# Step 6: Inspect Results
pdf('./Output/mcmcOutput1.pdf')
plot(as.mcmc(samples))
dev.off()
samples
# Step 6: Inspect Results
plot(samples[sigma])
# Step 6: Inspect Results
plot(samples[,sigma])
# Step 6: Inspect Results
plot(samples[,'sigma'])
# Step 6: Inspect Results
plot(samples['sigma'])
samples['sigma']
samples[,'sigma']
samples$chain1
samples$chain1[,'sigma']
# Step 6: Inspect Results
plot(samples$chain1[,'sigma'])
# Step 6: Inspect Results
plot(samples$chain1[,'sigma'], type = 'l')
# Step 6: Inspect Results
plot(samples$chain1[,'betaTrt[1]'], type = 'l')
samples
?samplesSummary()
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000, #1000
WAIC=TRUE,
nchains=1)
)
cat("Sampling time: ", time_baseline[3], "seconds.\n")
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
samples
colnames(samples)
summary(samples)
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000, #1000
WAIC=TRUE,
nchains=1)
)
cat("Sampling time: ", time_baseline[3], "seconds.\n")
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
colnames(samples)
summary(samples)
summary(samples)
# Watanabe-Akaike Information Criterion (WAIC): captures model fit
# Log Pointwise Predictive Density (LPPD): captures model complexity
# effective number of parameters in the model (pWAIC): balances previous two
# The relationship: WAIC=−2×lppd+2×pWAIC
WAIC <- TSSresults$WAIC
WAIC
# Step 6: Inspect Convergence
plot(samples$chain1[,'betaTrt[1]'], type = 'l')
# Step 6: Inspect Convergence
plot(samples[,'betaTrt[1]'], type = 'l')
# Step 6: Inspect Convergence
plot(samples[,'betaTrt[2]'], type = 'l')
# Step 6: Inspect Convergence
plot(samples[,'betaTrt[3]'], type = 'l')
