# Step 3: Compile the model and MCMC
cTSSmcmc <- compileNimble(TSSmcmc, project = model)
# Step 3: Compile the model and MCMC
cTSSmodel <- compileNimble(TSSmodel)
cTSSmcmc <- compileNimble(TSSmcmc, project = model)
cTSSmcmc <- compileNimble(TSSmcmc, project = TSSmodel)
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000,
WAIC=TRUE)
)
cat("Sampling time: ", time_baseline[3], "seconds.\n")
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
# WAIC (Note: there are different flavors of WAIC that can be chosen earlier.)
WAIC <- TSSresults$WAIC
# Step 6: Inspect Results
# We haven't provided coda figures, but you can make make them if you want.
# pdf("Ecervi_samples_coda.pdf")
plot(as.mcmc(samples))
dev.off()
cTSSmcmc$getWAIC()
# Step 6: Inspect Results
# We haven't provided coda figures, but you can make make them if you want.
# pdf("Ecervi_samples_coda.pdf")
plot(as.mcmc(samples))
TSSmodel$getNodeNames()
TSSmodel$tss
tss_df$tss
TSSmodel$simulate('tss')
TSSmodel$simulate()
TSSmodel$tss
samples
TSSmodel$getNodeNames()
plot(TSSmodel$graph, vertex.shape = "crectangle",
vertex.size = sizes,
vertex.size2 = 20,
layout = layout,
vertex.label.cex = 1.0,
vertex.color = fill.color,
edge.width = 3,
asp = 0.5,
edge.color = edge.color)
plot(TSSmodel$graph, vertex.shape = "crectangle",
vertex.size2 = 20,
layout = layout,
vertex.label.cex = 1.0,
vertex.color = fill.color,
edge.width = 3,
asp = 0.5,
edge.color = edge.color)
TSSmodel$graph
plot(TSSmodel$graph)
TSSmodel$sigma
TSSmodel$simulate('sigma')
TSSmodel$sigma
TSSmodel$calculate(TSSmodel$getDependencies('tss[1]'))
dev.off()
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
samples
# WAIC (Note: there are different flavors of WAIC that can be chosen earlier.)
WAIC <- TSSresults$WAIC
WAIC
log(358.5955)
log10(358.5955)
-2*-158.2396+2*21.05809
# Step 6: Inspect Results
# We haven't provided coda figures, but you can make make them if you want.
# pdf("Ecervi_samples_coda.pdf")
plot(as.mcmc(samples))
summary(tss_df)
sd(tss_df$tss)/sqrt(length((tss_df$tss)))
sd(tss_df$tss)
sd(tss_df$tss)*5
library('dplyr')
g <- ?summarise()
?summarize
tss_df %>% group_by(year) %>% summarise(sd = sd(tss), n=n())
# Step 1: Build the model
code <- nimbleCode({
# Fixed effects
beta0 ~ dnorm(0, sd = 2)
# Looping over the elements of betaTrt and betaYear
for(k in 1:3) {
betaTrt[k] ~ dnorm(0, sd = 2)
}
for(k in 1:maxYear) {
betaYear[k] ~ dnorm(0, sd = 2)
}
# Random effects
# Gelman (2006) recommends the uniform prior on the sd scale not the precision scale for random effects:
# E.g., u_yi[j] ~ dnorm(0, sd = tau_yi) NOT u_yi[j] ~ dnorm(0, tau_yi)
# yi
for(j in 1:nyi) {
u_yi[j] ~ dnorm(0, sd = tau_yi)
}
# block
for(j in 1:nblock) {
u_block[j] ~ dnorm(0, sd = tau_block)
}
# id
for(j in 1:nid) {
u_id[j] ~ dnorm(0, sd = tau_id)
}
tau_yi ~ dunif(0, 2)
tau_block ~ dunif(0, 2)
tau_id ~ dunif(0, 2)
sigma ~ dunif(0, 5) # prior for variance components based on Gelman (2006);
for(i in 1:n) {
tss[i] ~ dnorm(beta0 + betaTrt[trt[i]] + betaYear[year[i]] +
u_yi[yi[i]] + u_block[block[i]] + u_id[id[i]], sd = sigma)
}
})
constants <- list(
n = nrow(tss_df),
nyi = length(unique(tss_df$yi)),
nblock = length(unique(tss_df$block)),
nid = length(unique(tss_df$id)),
maxYear = length(unique(tss_df$year)),
# Converting factors to numeric below for MCMC
trt = as.numeric(tss_df$trt),
yi = as.numeric(tss_df$yi),
id = as.numeric(tss_df$id),
year = as.numeric(tss_df$year),
block = as.numeric(tss_df$block)
)
data <- list(
tss = tss_df$tss
)
inits <- list(
beta0 = mean(tss_df$tss),
betaTrt = rep(0, 3), # Initial values for three levels of 'trt'
betaYear = rep(0, constants$maxYear),
sigma = 1,
tau_yi = 1,
tau_block = 1,
tau_id = 1,
u_yi = rep(0, constants$nyi),
u_block = rep(0, constants$nblock),
u_id = rep(0, constants$nid)
)
TSSmodel <- nimbleModel(
code,
constants = constants,
data = data,
inits = inits
)
# Step 2: Build the MCMC
TSSmcmc <- buildMCMC(TSSmodel, enableWAIC = TRUE)
# Step 3: Compile the model and MCMC
cTSSmodel <- compileNimble(TSSmodel)
cTSSmcmc <- compileNimble(TSSmcmc, project = TSSmodel)
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000,
WAIC=TRUE)
)
cat("Sampling time: ", time_baseline[3], "seconds.\n")
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
# Watanabe-Akaike Information Criterion (WAIC): captures model fit
# Log Pointwise Predictive Density (LPPD): captures model complexity
# effective number of parameters in the model (pWAIC): balances previous two
# The relationship: WAIC=−2×lppd+2×pWAIC
WAIC <- TSSresults$WAIC
WAIC
samples
# Step 6: Inspect Results
plot(as.mcmc(samples))
# Get standard deviation of tss and tssl
tss_df %>% group_by(year) %>% summarise(sd_conc = sd(tss),
sd_load = sd(tssl),
n=n()
)
# Step 1: Build the model
code <- nimbleCode({
# Fixed effects
beta0 ~ dnorm(0, sd = 0.8)
# Looping over the elements of betaTrt and betaYear
for(k in 1:3) {
betaTrt[k] ~ dnorm(0, sd = 0.8)
}
for(k in 1:maxYear) {
betaYear[k] ~ dnorm(0, sd = 0.8)
}
# Random effects
# Gelman (2006) recommends the uniform prior on the sd scale not the precision scale for random effects:
# E.g., u_yi[j] ~ dnorm(0, sd = tau_yi) NOT u_yi[j] ~ dnorm(0, tau_yi)
# yi
for(j in 1:nyi) {
u_yi[j] ~ dnorm(0, sd = tau_yi)
}
# block
for(j in 1:nblock) {
u_block[j] ~ dnorm(0, sd = tau_block)
}
# id
for(j in 1:nid) {
u_id[j] ~ dnorm(0, sd = tau_id)
}
tau_yi ~ dunif(0, 2)
tau_block ~ dunif(0, 2)
tau_id ~ dunif(0, 2)
sigma ~ dunif(0, 2) # prior for variance components based on Gelman (2006);
for(i in 1:n) {
tss[i] ~ dnorm(beta0 + betaTrt[trt[i]] + betaYear[year[i]] +
u_yi[yi[i]] + u_block[block[i]] + u_id[id[i]], sd = sigma)
}
})
constants <- list(
n = nrow(tss_df),
nyi = length(unique(tss_df$yi)),
nblock = length(unique(tss_df$block)),
nid = length(unique(tss_df$id)),
maxYear = length(unique(tss_df$year)),
# Converting factors to numeric below for MCMC
trt = as.numeric(tss_df$trt),
yi = as.numeric(tss_df$yi),
id = as.numeric(tss_df$id),
year = as.numeric(tss_df$year),
block = as.numeric(tss_df$block)
)
data <- list(
tss = tss_df$tss
)
inits <- list(
beta0 = mean(tss_df$tss),
betaTrt = rep(0, 3), # Initial values for three levels of 'trt'
betaYear = rep(0, constants$maxYear),
sigma = 1,
tau_yi = 1,
tau_block = 1,
tau_id = 1,
u_yi = rep(0, constants$nyi),
u_block = rep(0, constants$nblock),
u_id = rep(0, constants$nid)
)
TSSmodel <- nimbleModel(
code,
constants = constants,
data = data,
inits = inits
)
# Step 2: Build the MCMC
TSSmcmc <- buildMCMC(TSSmodel, enableWAIC = TRUE)
# Step 3: Compile the model and MCMC
cTSSmodel <- compileNimble(TSSmodel)
cTSSmcmc <- compileNimble(TSSmcmc, project = TSSmodel)
# Step 4: Run the MCMC
time_baseline <- system.time(TSSresults <- runMCMC(cTSSmcmc,
niter=11000,
nburnin=1000,
WAIC=TRUE)
)
cat("Sampling time: ", time_baseline[3], "seconds.\n")
# Step 5: Extract the samples and WAIC
# Samples
samples <- TSSresults$samples
# Watanabe-Akaike Information Criterion (WAIC): captures model fit
# Log Pointwise Predictive Density (LPPD): captures model complexity
# effective number of parameters in the model (pWAIC): balances previous two
# The relationship: WAIC=−2×lppd+2×pWAIC
WAIC <- TSSresults$WAIC
WAIC
# Step 6: Inspect Results
plot(as.mcmc(samples))
dev.off()
# Step 6: Inspect Results
plot(as.mcmc(samples))
# Get standard deviation of tss and tssl
sd(tss_df$tss_df)
# Get standard deviation of tss and tssl
sd(tss_df$tss)
sd(tss_df$tssl)
tss_df %>% group_by(year) %>% summarise(sd_conc = sd(tss),
sd_load = sd(tssl),
n=n()
)
tss_df %>% group_by(year) %>% summarise(sd_conc = sd(tss),
sd_load = sd(tssl),
n=n()
)
tss_df %>% group_by(block) %>% summarise(sd_conc = sd(tss),
sd_load = sd(tssl),
n=n()
)
tss_df %>% group_by(id) %>% summarise(sd_conc = sd(tss),
sd_load = sd(tssl),
n=n()
)
# sd by yi
tss_df %>% group_by(yi) %>% summarise(sd_conc = sd(tss),
sd_load = sd(tssl),
n=n())
# Import libraries
package.list <- c(
'nimble',
'coda',
'lme4',
'lmerTest',
'lsmeans',
'ggplot2',
'dplyr',
'tidyr'
)
packageLoad <- function(packages){
for (i in packages) {
if (!require(i, character.only = TRUE)) {
install.packages(i)
library(i, character.only = TRUE)
}
}
}
packageLoad(package.list)
recommend_priors <- function(df) {
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
block = max(sd(tss[block == 1]), sd(tss[block == 2])),
year = max(tapply(tss, year, sd)),
yi = max(tapply(tss, yi, sd)),
id = max(tapply(tss, id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
recommend_priors(tss_df)
recommend_priors <- function(var=tss, df) {
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
block = max(sd(var[block == 1]), sd(var[block == 2])),
year = max(tapply(var, year, sd)),
yi = max(tapply(var, yi, sd)),
id = max(tapply(var, id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
recommend_priors(var='tss')
recommend_priors(var='tss', df=tss_df)
recommend_priors(var=tss, df=tss_df)
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
block = max(tapply(.data[[column_name]], block, sd)),
year = max(tapply(.data[[column_name]], year, sd)),
yi = max(tapply(.data[[column_name]], yi, sd)),
id = max(tapply(.data[[column_name]], id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
# Test the function
recommend_priors(df=tss_df, column_name='tss')
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
cat(paste0("Recommended priors based on column: '", column_name, "'\n\n"))
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
block = max(tapply(.data[[column_name]], block, sd)),
year = max(tapply(.data[[column_name]], year, sd)),
yi = max(tapply(.data[[column_name]], yi, sd)),
id = max(tapply(.data[[column_name]], id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
print()
return(recommended_prior_table)
}
# Test the function
recommend_priors(df=tss_df, column_name='tss')
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
cat(paste0("Recommended priors based on column: '", column_name, "'\n\n"))
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
block = max(tapply(.data[[column_name]], block, sd)),
year = max(tapply(.data[[column_name]], year, sd)),
yi = max(tapply(.data[[column_name]], yi, sd)),
id = max(tapply(.data[[column_name]], id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
# Test the function
recommend_priors(df=tss_df, column_name='tss')
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
cat(paste0("Recommended priors based on column: '", column_name, "'\n\n"))
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
block = max(tapply(.data[[column_name]], block, sd)),
year = max(tapply(.data[[column_name]], year, sd)),
yi = max(tapply(.data[[column_name]], yi, sd)),
id = max(tapply(.data[[column_name]], id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
# Test the function
recommend_priors(tss_df, 'tss')
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
cat(paste0("Recommended priors based on column: '", column_name, "'\n\n"))
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
trt = max(tapply(.data[[column_name]], trt, sd))
block = max(tapply(.data[[column_name]], block, sd)),
# Test the function
recommend_priors(tss_df, 'tss')
recommend_priors <- function(df, column_name) {
# Ensure column_name exists in the dataframe
if (!(column_name %in% colnames(df))) {
stop(paste0("The column '", column_name, "' does not exist in the dataframe."))
}
cat(paste0("Recommended priors based on column: '", column_name, "'\n\n"))
# Compute the maximum standard deviation for each effect
max_sd <- df %>%
summarise(
trt = max(tapply(.data[[column_name]], trt, sd)),
block = max(tapply(.data[[column_name]], block, sd)),
year = max(tapply(.data[[column_name]], year, sd)),
yi = max(tapply(.data[[column_name]], yi, sd)),
id = max(tapply(.data[[column_name]], id, sd))
)
# Double the max standard deviation and round to the nearest whole number
doubled_rounded <- round(2 * max_sd)
# Combine the results into a table
recommended_prior_table <- bind_cols(
effect = names(max_sd),
identified_max = as.numeric(max_sd),
recommended_prior = as.numeric(doubled_rounded)
)
return(recommended_prior_table)
}
# Test the function
recommend_priors(tss_df, 'tss')
# Test the function
priors_tss <- recommend_priors(tss_df, 'tss')
priors_tssl <- recommend_priors(tss_df, 'tssl')
priors_tss
priors_tssl <- recommend_priors(tss_df, 'tssl')
priors_tssl
